##  Идеи проектов - 2023

Новацией - 2023 является разделение проектов на кластеры.
Студенты работают в группах 2-3 человека, делая относительно
компактные проекты. Однако, предполагается, что проекты из
одного кластера будут друг с другом совместимы и можно будет
собрать из них что-то большое и интересное.

Во многом, новация вызвана тем, что одношаговые идеи проектов
уже все перепробованы. Написать ещё один gossip чат совсем не
радует, их было уже несколько в предыдущие годы. А вот сделать
формат данных, на котором собирать совместимые gossip чаты,
микснеты, системы поиска и хранения, и так далее, это была бы
очень интересная затея.

### A. Кластер распределённая LSM база данных

Внутренний формат записи в типичной LSM базе данных:
 - ключ (строка)
 - значение (строка)
 - версия, он же seq (`uint64_t`, последовательно назначаемые)

Синхронизация в такой БД возможна только master-slave,
последовательной подачей лога операций (записей).  Мы немножко
доопределим формат: добавим понятие лампортова ID (lamport
timestamp) на основе seq.  lseq это 64 битный идентификатор, где
верхние 5 байт это seq, а нижние 3 это id реплики.  

`lseq = (seq<<24) | id`

С таким версионированием, мы можем синхронизировать реплики в
произвольной топологии, как в git.

Этот формат может породить следующие проекты:

 1. lseq хранилище на основе leveldb/rocksdb/pebble (C++/go) с
 возможностью синхронизации с удалёнными репликами по сети
 2. система контроля версий, сохраняющая данные (построчно) в
 lseq хранилище (key-value пара это строка, diff скажет какие
 строки класть/удалять)
 3. ORM подобный маппер объектов (в вашем любимом языке) из/в
 lseq хранилище
 4. криптографическая верификация lseq хранилища (читаем записи,
 хэшируем, подписываем, сохраняем подписи и хэши в lseq же, так
 же - проверяем целостность)
 5. восстановление исторических версий lseq хранилища (снапшоты)
 - для seq это встроенный функционал, а вот для lseq нужно
 реализовать векторные часы.
 
 Внутренний формат lseq хранилища выработать совместно.

### B. Кластер Белый Шум

Как известно, единственная гарантированно невзламываемая система
шифрования - это гаммирование белым шумом. Предлагается развить
этот подход, насколько это возможно. 

Для шифрования используем оффлайновые мобильные устройства
(старый смартфон). Единица белого шума - это 32 байтовый блок.
Каждое устройство имеет некоторое количество файлов белого шума.
Шум в файле считается достаточно белым, если там нет двух
одинаковых 32 байтовых блоков. На практике, можно попробовать
видео-файлы (сомнительно), дампы urandom (чуть лучше), что
угодно.  Каждый файл условно считается бесконечным, зацикленным.
Для красоты, каждый файл идентифицируется эмодзи. Передаются
файлы на носителе (допустим, это micro SD карта).

"Ключом" является последовательность эмодзи.

Гамма для шифрования сообщений генерируется, как
    `SHA( SHA( SHA(fileA[posA]), fileB[posB]), fileC[posC])`
где очередной `posX` также получается через хэширование ключа
со смещением в потоке.

Если шум достаточно белый и хотя бы один файл не известен
атакующему, перспективы расшифровки выглядят туманными.

Теперь заметим, что:

 1. количество разных ключей для шифрования потоков
    имеет порядок n! где n количество файлов в природе
 2. количество возможных наборов файлов на устройстве имеет
    порядок 2^n
 3. файлы могут быть довольно большими (32GB легко)
 4. файлы будет довольно трудно украсть с оффлайнового
    устройства, и даже по bluetooth затруднительно
 5. создание новых файлов и их распространение не требует
    особых навыков, если участники изредка встречаются
    (делаем micro SD карту, передаём по цепочке k раз,
    затем уничтожаем - "эпидемический протокол") n->8
 6. наличие старого смартфона с видеофайлами не палевно,
    а сетевой чип у него сам сломался
    (как сделать непалевным качественный БШ - вопрос)

Заметим, что при использовании симметричного шифра, требуется
примерно то же, но файл будет размером 32b, а не 32GB. На данном
этапе развития технологии, практическая разница тут крайне мала,
если только вы не надиктовываете ключи по телефону и не пишете
их на бумаге - это будет носитель тех же размеров.

Что тут можно сделать интересного:

 1. приложение для Android, управляющее файлами и шифрованием
 2. QR интерфейс для отправки/получения сообщений оффлайн,
    выбора сессионных ключей, итд
 3. Base64(?) либо другой текстовый интерфейс для
    перепечатывания абракадабры с экрана
 4. аналитически, либо через вычислительный эксперимент
    исследовать возможности масштабирования системы - протоколы
    обмена файлами и выбора ключей, минимизирующие вероятность
    компроментации сообщения при известном проценте
    скомпроментированных участников (напр. "для надёжной
    расшифровки нужно 51% предателей" - хороший результат)
    Важно: в тексте, вместо слова "злоумышленник" используем
    термин ["Мориарти"][m]
 5. если кто-то расхрабрится - аудио-интерфейс; для получения и
    передачи сообщений хватает, для утечки файлов точно нет

[m]: https://www.youtube.com/watch?v=vwoPSdtFqHg

### C. Кластер Мессенджеры и чаты

Основная идея децентрализованного чата - что держателем данных и
реализацией логики является конечное устройство, а сервера
являются взаимозаменяемыми средствами транспорта, если вообще
используются. Возможно паразитическое использование транспорта,
когда мы пересылаем сообщения через сети других мессенджеров.
Возможна реализация своих, федерированных, серверов.
Это фактически переиспользование end-to-end principle, как он
применялся в протоколах TCP/IP. Подразумевается, что на клиенте
теперь чуть больше логики - он должен уметь синхронизироваться.

 1. само приложение - интерфейс и хранилище (Android),
 2. федерированный сервер,
 3. транспорты поверх Х, где Х это TCP, HTTP, WhatsApp,
    Telegram, BitTorrent DHT, что угодно (совместимое с C.1).

Модель данных.

 1. Контакт - это публичный ключ, Ed25519.
 2. Линк - это способ связи с контактом: URL или контакт в IM в
    формате URN или другой URI, определяющий способ связи.
 3. id сообщения имеет формат `5+3=4+1+3`, 4 байта Unix time,
    1 байт seq (порядковый номер в пределах секунды), 3 байта
    идентификатор реплики (префикс ключа). Это достаточно
    совместимо с lseq в кластере А.
 4. Формат сообщения: (id, ref, text), где id это собственный
    id сообщения, а ref это id сообщения, на которое мы отвечаем
    (если просто пишем в чат, то это id заглавного сообщения,
    создавшего чат). Таким образом, один чат - это дерево
    сообщений. text это просто UTF-8.
 5. Сообщения хранятся в key-value базе данных (как в А).

### D. Кластер QR code based apps

Выход в оффлайн, в двух смыслах.  Во-первых, как в ЮВА, мы можем
использовать QR коды в оффлайне для различных взаимодействий.
Во-вторых, QR интерфейс позволяет использовать оффлайновые
устройства (без интернет соединения).

