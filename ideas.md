#   Идеи проектов - 2023

Новацией - 2023 является разделение проектов на кластеры.
Студенты работают в группах 2-3 человека, делая относительно
компактные проекты. Однако, предполагается, что проекты из
одного кластера будут друг с другом совместимы и можно будет
собрать из них что-то большое и интересное.

Во многом, новация вызвана тем, что одношаговые идеи проектов
уже все перепробованы. Написать ещё один gossip чат совсем не
радует, их было уже несколько в предыдущие годы. А вот сделать
формат данных, на котором собирать совместимые gossip чаты,
микснеты, системы поиска и хранения, и так далее, это была бы
очень интересная затея.

##  A. Кластер распределённая LSM база данных

Log-structured Merge Tree это широко используемый тип БД.
Как мы видим на примере Cassandra и её клонов, такие БД могут
работать в распределённом режиме. В случае Кассандры это LWW,
мы же попробуем сделать каузальную (causal tree, CRDT) БД. 
Низкоуровневые вещи нам писать незачем - всё уже написано.
Мы просто добавим логику синхронизации реплик.

### Модель данных: БД с частичным (лампортовым) порядком

Внутренний формат записи в типичной LSM базе данных:
 - ключ (строка)
 - значение (строка)
 - версия, он же seq (`uint64_t`, последовательно назначаемые)

 `[seq] key: value`

Синхронизация в такой БД возможна только master-slave,
последовательной подачей лога операций (записей).  Мы немножко
доопределим формат: добавим понятие лампортова ID (lamport
timestamp) на основе seq.  lseq это 64 битный идентификатор, где
верхние 5 байт это seq, а нижние 3 это id реплики.  

`lseq = (seq<<24) | id`

С таким версионированием, мы можем синхронизировать реплики в
произвольной топологии, как в git. С теоретической точки зрения,
мы добавили немного релятивизма: теперь у нас время всегда даётся
относительно некоторой системы отсчёта. Обратим внимание, что
у нас автоматически сформировался частичный (каузальный) порядок:
реплика, которая видела операцию с `seq=x`, будет создавать новые
операции с `seq>x`.

В зависимости от наших целей, мы можем хранить записи, как:

````
    [seq] key,lseq: value
    [seq] lseq,key: value
    [seq] key: lseq,value
````

Если мы хотим создать индексы, value переходит налево, например
`[xxx] value,lseq: key`. Как-то так LSM хранилищами и пользуются
обычно, тот же RocksDB - это LEGO набор для создания кастомных БД.

### Проекты A

Этот формат может породить следующие проекты:

 1. lseq хранилище на основе leveldb/rocksdb/pebble (C++/go) с
 возможностью синхронизации с удалёнными репликами по сети
 2. (переехало в C)
 3. ORM подобный маппер объектов (в вашем любимом языке) из/в
 lseq хранилище
 4. криптографическая верификация lseq хранилища (читаем записи,
 хэшируем, подписываем, сохраняем подписи и хэши в lseq же, так
 же - проверяем целостность)
 5. восстановление исторических версий lseq хранилища (снапшоты)
 - для seq это встроенный функционал, а вот для lseq нужно
 реализовать векторные часы (vector clock/version vector).
 
 Внутренний формат lseq хранилища выработать совместно.

## B. Кластер Белый Шум

Как известно, единственная гарантированно невзламываемая система
шифрования - это гаммирование белым шумом (по теореме Шеннона). 
Предлагается развить этот подход, насколько это возможно. 

### Модель данных B

Для шифрования используем оффлайновые мобильные устройства
(старый смартфон). Единица белого шума - это 32 байтовый блок.
Каждое устройство имеет некоторое количество файлов белого шума.
Шум в файле считается достаточно белым, если там нет двух
одинаковых 32 байтовых блоков. На практике, можно попробовать
видео-файлы (сомнительно), дампы urandom (чуть лучше), что
угодно.  Каждый файл условно считается бесконечным, зацикленным.
Для красоты, каждый файл идентифицируется эмодзи. Передаются
файлы на носителе (допустим, это micro SD карта).

"Ключом" является последовательность эмодзи.

Гамма для шифрования сообщений генерируется, как
    `SHA( SHA( SHA(fileA[posA]), fileB[posB]), fileC[posC])`
где очередной `posX` также получается через хэширование ключа
со смещением в потоке.

Если шум достаточно белый и хотя бы один файл не известен
атакующему, перспективы расшифровки выглядят туманными.

Теперь заметим, что:

 1. количество разных ключей для шифрования потоков
    имеет порядок n! где n количество файлов в природе
 2. количество возможных наборов файлов на устройстве имеет
    порядок 2^n
 3. файлы могут быть довольно большими (32GB легко)
 4. файлы будет довольно трудно украсть с оффлайнового
    устройства, и даже по bluetooth затруднительно
 5. создание новых файлов и их распространение не требует
    особых навыков, если участники изредка встречаются
    (делаем micro SD карту, передаём по цепочке k раз,
    затем уничтожаем - "эпидемический протокол") n->8
 6. наличие старого смартфона с видеофайлами не палевно,
    а сетевой чип у него сам сломался
    (как сделать непалевным качественный БШ - вопрос)

Заметим, что при использовании симметричного шифра, требуется
примерно то же, но файл будет размером 32b, а не 32GB. На данном
этапе развития технологии, практическая разница тут крайне мала,
если только вы не надиктовываете ключи по телефону и не пишете
их на бумаге - это будет носитель тех же размеров.

### Проекты B

Что тут можно сделать интересного:

 1. приложение для Android, управляющее файлами и шифрованием
 2. переехало в D
 3. Base64(?) либо другой текстовый интерфейс для
    перепечатывания абракадабры с экрана
 4. аналитически, либо через вычислительный эксперимент
    исследовать возможности масштабирования системы - протоколы
    обмена файлами и выбора ключей, минимизирующие вероятность
    компроментации сообщения при известном проценте
    скомпроментированных участников (напр. "для надёжной
    расшифровки нужно 51% предателей" - хороший результат)
    Важно: в тексте, вместо слова "злоумышленник" используем
    термин ["Мориарти"][m]
 5. если кто-то расхрабрится - аудио-интерфейс; для получения и
    передачи сообщений хватает, для утечки файлов точно нет.
 6. А теперь жесткач: для шифрования БД используем в качестве
    белого шума саму БД. То есть, получить обновления может
    только тот, у кого уже есть данные. В таком случае, для
    репликации БД есть две операции: клонирование реплики с
    назначением нового id и синхронизация реплик, использующая
    общую историю в качестве белого шума. Тут, можно понимать
    историю операций от одной реплики, как один файл белого
    шума (например, от каждой записи брать SHA256). Можно
    пересечение всех имеющихся данных. Сопрягается с А.1, 
    возможно А.5 и A.4 в части дерева хэшей.

[m]: https://www.youtube.com/watch?v=vwoPSdtFqHg

## C. Кластер Мессенджеры и чаты

Основная идея децентрализованного чата - что держателем данных и
реализацией логики является конечное устройство, а сервера
являются взаимозаменяемыми средствами транспорта, если вообще
используются. Возможно паразитическое использование транспорта,
когда мы пересылаем сообщения через сети других мессенджеров.
Возможна реализация своих, федерированных, серверов.
Это фактически переиспользование end-to-end principle, как он
применялся в протоколах TCP/IP. Подразумевается, что на клиенте
теперь чуть больше логики - он должен уметь синхронизироваться.

### Модель данных C

Модель данных C является специализацией модели данных LSM(A),
c расчётом что проекты С могут использовать средства А. Тут 
также используются те же 64 битные идентификаторы с теми же
свойствами частичного порядка. Поле key здесь становится 64bit
идентификатором lseq. Теперь оно называется ref, это указатель
на causal parent, родительскую запись. Например, в чате ref -
это id сообщения, на которое мы отвечаем, а если просто пишем 
в чат, то это id заглавного сообщения, создавшего чат). 
Таким образом, один чат - это дерево сообщений, из которого
можно выделять поддеревья - нити (threads). Value это всегда
utf-8 строка.

Обратите внимание, что линейный порядок сообщений получается
обходом этого дерева, depth-first preorder traversal. Если
нам нужно разложить thread в дерево, сиблинги идут от старых
к новым (asc id), получится порядок, как в email клиенте. 
Если нам нужно сделать causal tree (напр. собрать текстовый файл
из построчного CRDT), сиблинги идут от новых к старым (desc id).
В чате же мы предпочтём либо хронологический порядок (lseq)
либо даже разложим сообщения в порядке получения (seq), хоть
он и разный на разных репликах.

Также, `контакт` - это публичный ключ, Ed25519, а `линк` - это
способ связи с контактом: URL или контакт в IM в формате URN или
другой URI, определяющий способ связи.

Все записи в такой БД можно объединить в одно большое дерево,
например чаты и сообщения, каталоги и файлы. Эти типы записей
мы будем различать по синтаксису value и типу parent. Допустим,
запись - каталог имеет value `dir_name/`, файл `file.txt$`, а
симлинк `alias.txt<file.txt>`.

### Проекты C

 1. само приложение - интерфейс мессенджера и хранилище 
    (Android), использующий сервер A.1/C.2 либо прямой
    обмен с другими участниками через транспорты C.3.
 2. федерированный сервер, способный делать поиск по БД и
    отвечать на клиенские запросы (напр. обновления для чата
    либо обновления для проекта в системе контроля версий,
    либо выбор thread контекста для заданного сообщения);
    логику федерирования позаимствовать из A.1;
 3. транспорты поверх Х, где Х это TCP, HTTP, WhatsApp,
    Telegram, BitTorrent DHT, что угодно (совместимое с C.1).
 4. система контроля версий, сохраняющая данные (построчно) в
    LSM(C) хранилище (key-value запись это строка, diff скажет
    какие строки класть/удалять) - клиентский CLI код со своим
    локальным хранилищем, использующий сервер из C.2/A.1.
    Криптографию и восстановление исторических версий взять
    из A.4/A.5.

## D. Кластер QR code based apps

Выход в оффлайн, в двух смыслах.  Во-первых, как в ЮВА, мы можем
использовать QR коды в оффлайне для различных взаимодействий.
Во-вторых, QR интерфейс позволяет использовать оффлайновые
устройства (без интернет соединения).

### Модель данных D

QR код необходимого разрешения; формат сообщений определяется
в A и C.

### Проекты D

 1. для С.1, QR интерфейс для отправки/получения сообщений
    оффлайн, выбора сессионных ключей, итд (также C.3)
 2. реализация Диффи-Хеллмана через QR диалог двух телефонов
    (экран показывает QR, фронтальные камеры распознают)
 3. экспорт базы из A в QR-видео, которое может пережить
    пересжатие на сервисах YouTube, Telegram итп, а также
    экранку (видео экрана); импорт таких видео.
